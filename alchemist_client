#!/usr/bin/env python
from __future__ import print_function
import os, sys, tempfile
import subprocess, shlex, socket
import getopt, re
import syslog
import time
import traceback
import pprint

debug = False

elixir_fun_with_arity = re.compile(r'(?P<func>.*)/[0-9]+$')
re_erlang_module = re.compile(r'^(?P<module>.*)')

def alchemist_help():
    return """Usage: alchemist_client -c <command> -t <command_type> -d <working_directory> -a <alchemist_script>

    a client that talks to alchemist_server through network socket

    Options:
    -c, --command=""           Command that is going to be sent to alchemist server if nothing is provided read a line from STDIN
    -t, --command-type=""      Command type, if it's not provided, extract it from command
    -d, --directory=           Directory that alchemist server should process code from
    -a, --alchemist-server=""  Path to alchemist server `run.exs`, if it's not provided load it from alchemist-server/run.exs
    --colors=true              Enable/Disable ansi
    """

def main(argv):
    cmd_type = ""
    cmd = ""
    cwd = ""
    alchemist_script = ""
    ansi = True
    try:
        opts, args = getopt.getopt(argv,"hc:t:d:a:",["type=","command-type=", "directory=", "alchemist-server=", "colors="])
    except getopt.GetoptError:
        print(alchemist_help())
        sys.exit(2)
    for opt, arg in opts:
        if opt == '-h':
            print(alchemist_help())
            sys.exit()
        elif opt in ("-c", "--command"):
            cmd = arg
        elif opt in ("-t", "--command-type"):
            cmd_type = arg
        elif opt in ("-d", "--directory"):
            cwd = arg
        elif opt in ("-a", "--alchemist-server"):
            alchemist_script = arg
        elif opt in ("--colors"):
            if arg == "false":
                ansi = False
    if os.path.exists(cwd.strip()) == False:
        raise Exception("working directory [%s] doesn't exist" % cwd)
    cwd = get_project_base_dir(os.path.abspath(arg))
    if cmd == "":
        cmd = raw_input()
    if alchemist_script == "":
        alchemist_script = "%s/alchemist-server/run.exs" % where_am_i()
    if cmd_type == "":
        cmd_type = cmd.split(" ")[0]
    debug("cmd_type:%s, cmd:%s, cwd:%s, alchemist_script:%s" %
            (cmd_type, cmd, cwd, alchemist_script))

    if cmd == "" or cmd_type == "" or alchemist_script == "" or cwd == "":
        print(alchemist_help())
        sys.exit(2)

    process_command(cmd_type, cmd, cwd, ansi, alchemist_script)


def where_am_i():
    return os.path.dirname(os.path.realpath(__file__))

def process_command(cmd_type, cmd, cwd, ansi, alchemist_script):
    server_log = get_server_log(cwd)
    if server_log == None:
        server_log = create_server_log(cwd)
        run_alchemist_server(alchemist_script, server_log, cwd, ansi)

    connection = extract_connection_settings(server_log)
    if connection == None:
        run_alchemist_server(alchemist_script, server_log, cwd, ansi)
        connection = extract_connection_settings(server_log)

    sock = connect(connection)
    if sock == None:
        run_alchemist_server(alchemist_script, server_log, cwd, ansi)
        connection = extract_connection_settings(server_log)
        sock = connect(connection)

    result = send_command(sock, cmd_type, cmd)
    print(result, end="")
    debug(result)


def run_alchemist_server(alchemist_script, server_log, cwd, ansi):
    if os.path.exists(alchemist_script) == False:
        raise Exception("alchemist script does not exist in (%s)" % alchemist_script)
    alchemist_script = "elixir %s --env=dev --listen" % alchemist_script
    if ansi == False:
        alchemist_script = "%s --no-ansi" % alchemist_script
    alchemist_script = "%s %s" % (alchemist_script, cwd)
    arg = shlex.split(alchemist_script)
    log_file = open(server_log, "w")
    subprocess.Popen(arg, stdout=log_file, stderr=log_file, cwd=cwd)
    for t in range(1, 5):
        time.sleep(t/10.1)
        if len(open(server_log).readlines()) > 0:
            break

def connect(host_port):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    try:
        sock.connect(host_port)
    except socket.error as e:
        debug("Can not establish connection to %s, error: %s" % (host_port, e))
        return None

    if is_connection_alive(sock) == False:
        sock.close()
        return None
    return sock

def send_command(sock, cmd_type, cmd):
    sock.sendall(cmd + "\n")
    result = ''
    for line in readlines(sock):
        result += "%s\n" % line
        if line.strip() == "END-OF-%s" % cmd_type: break
        if line.strip() == "END, func_puts-OF-DOCL": break

    return result

def readlines(sock, recv_buffer=4096, delim='\n'):
    buffer = ''
    data = True
    while data:
        data = sock.recv(recv_buffer)
        buffer += data

        while buffer.find(delim) != -1:
            line, buffer = buffer.split('\n', 1)
            yield line
    return

def is_connection_alive(sock):
    if send_command(sock, "PING", "PING") == "PONG\nEND-OF-PING\n":
        True
    False

def extract_connection_settings(server_log):
    """
    >>> server_log = "t/fixtures/alchemist_server/valid.log"
    >>> print(extract_connection_settings(server_log))
    ('localhost', 2433)

    >>> server_log = "t/fixtures/alchemist_server/invalid.log"
    >>> print(extract_connection_settings(server_log))
    None
    """
    for line in open(server_log, "r").readlines():
        match = re.search(r'ok\|(?P<host>\w+):(?P<port>\d+)', line)
        if match:
            (host, port) = match.groups()
            return (host, int(port))
            break
    return None


def get_server_log(cwd):
    dir_tmp = "%s/alchemist_server" % (get_tmp_dir())
    log_tmp = "%s/%s" % (dir_tmp, cwd.replace("/", "zS"))
    if os.path.exists(dir_tmp) == False:
        return None

    if os.path.exists(log_tmp) == True:
        return log_tmp

    return None

def create_server_log(cwd):
    dir_tmp = "%s/alchemist_server" % (get_tmp_dir())
    log_tmp = "%s/%s" % (dir_tmp, cwd.replace("/", "zS"))
    if os.path.exists(dir_tmp) == False:
        os.makedirs(dir_tmp)

    if os.path.exists(log_tmp) == False:
        return log_tmp

    return None

def get_tmp_dir():
    """
    >>> os.environ['TMPDIR'] = '/tmp/foo01/'
    >>> get_tmp_dir()
    '/tmp/foo01/'
    >>> del os.environ['TMPDIR']
    >>> os.environ['TEMP'] = '/tmp/foo02/'
    >>> get_tmp_dir()
    '/tmp/foo02/'
    >>> del os.environ['TEMP']
    >>> os.environ['TMP'] = '/tmp/foo03/'
    >>> get_tmp_dir()
    '/tmp/foo03/'
    >>> del os.environ['TMP']
    >>> get_tmp_dir() == tempfile.tempdir
    True
    """
    for var in ['TMPDIR', 'TEMP', 'TMP']:
        if var in os.environ:
            return os.environ[var]
    if tempfile.tempdir != None:
        return tempfile.tempdir

    return "/tmp/"

def get_project_base_dir(cwd, running_servers_logs=None):
    """
    >>> #prepare the test env
    >>> tmp_dir = tempfile.mkdtemp()
    >>> p01_dir = os.path.join(tmp_dir, "p01")
    >>> os.mkdir(p01_dir)
    >>> p01_lib_dir = os.path.join(p01_dir, "lib")
    >>> os.mkdir(p01_lib_dir)
    >>> p01_log = p01_dir.replace("/", "zS")
    >>> #end
    >>> #detect that base dir is already running
    >>> get_project_base_dir(p01_dir, [p01_log]) == p01_dir
    True
    >>> #since server is running on base dir, if lib dir is given, should return base dir
    >>> get_project_base_dir(p01_lib_dir, [p01_log]) == p01_dir
    True
    >>> #if given dir is out of base dir, should return the exact dir
    >>> get_project_base_dir(tmp_dir, [p01_log]) == tmp_dir
    True
    >>> #since there is no running server, lib dir is detected as base dir
    >>> get_project_base_dir(p01_lib_dir, []) == p01_lib_dir
    True
    >>> #prepare mix test
    >>> open(os.path.join(p01_dir, "mix.exs"), 'a').close()
    >>> #should find mix.exs recursively and return base dir
    >>> get_project_base_dir(p01_lib_dir, []) == p01_dir
    True
    """

    if running_servers_logs == None:
        dir_tmp = "%s/alchemist_server" % (get_tmp_dir())
        running_servers_logs = os.listdir(dir_tmp)
    paths = cwd.split(os.sep)
    mix_dir = []
    for i in range(len(paths)):
        project_dir = os.sep.join(paths[:len(paths)-i])
        log_tmp = "%s" % project_dir.replace("/", "zS")
        if log_tmp in running_servers_logs:
            return project_dir

        if os.path.exists(os.path.join(project_dir, "mix.exs")):
            mix_dir.append(project_dir)

    if len(mix_dir):
        return mix_dir.pop(0)

    return cwd

def func_auto_complete(base, first, suggestion):
    """
    >>> pprint.pprint(func_auto_complete("Li", "List.", "first/1"))
    {'abbr': 'first/1', 'kind': 'f', 'word': 'List.first'}
    >>> pprint.pprint(func_auto_complete("List.f", "List.first", "first/1"))
    {'abbr': 'first/1', 'kind': 'f', 'word': 'List.first'}
    >>> pprint.pprint(func_auto_complete("g", "get_", "get_in/2"))
    {'abbr': 'get_in/2', 'kind': 'f', 'word': 'get_in'}
    """
    func_dict = {'kind': 'f', 'abbr': suggestion}
    func_name = elixir_fun_with_arity.match(suggestion).group('func')
    word = "%s%s" % (first, func_name)

    func_parts = base.split('.')
    if len(func_parts) > 1:
        word = ".".join(func_parts[:len(func_parts)-1])
        word = "%s.%s" % (word, func_name)
    elif first[-1] != '.':
        word = func_name

    func_dict['word'] = word
    return func_dict

def erlang_mod_auto_complete(base, first, suggestion):
    """
    >>> pprint.pprint(erlang_mod_auto_complete(':gen', ':gen', 'gen'))
    {'abbr': ':gen', 'kind': 'm', 'word': ':gen'}
    >>> #pprint.pprint(erlang_mod_auto_complete(':g', ':g', 'gb_sets'))
    """
    #TODO: to check case: :gen.^X^O => base ":gen." ==> :gen.
    mod_dict = {'kind': 'm', 'abbr': ':%s' % suggestion}
    mod_name = ':%s' % re_erlang_module.match(suggestion).group('module')
    mod_dict['word'] = mod_name

    return mod_dict

def debug(text):
    if debug == False:
        return
    syslog.openlog("alchemist_client")
    syslog.syslog(syslog.LOG_ALERT, text)


if __name__ == "__main__":
    debug("starting alchemist_client...")

    try:
        if "--test" in sys.argv[1:]:
            import doctest
            doctest.testmod()
            sys.exit()
        main(sys.argv[1:])
    except Exception as e:
        debug("Exception occurred: %s" % traceback.format_exc())
        print("error: %s" % e.message)
        sys.exit(1)

    debug("done.")


